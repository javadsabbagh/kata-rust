# Appendix I - Glossary

* ADT(Algebraic Data Type: Algebraic Data Type):
* ARC(Atomic Reference Counting: Atomic Reference Counting):
* associated function (associated function):
* associated type (associated type): Trait can have associated types
* AST(Abstract Syntax Tree: Abstract Syntax Tree):
* benchmark (benchmark test):
* bitwise copy:
* borrow (borrow):
* bounds (constraints):
* box:
* byte string():
* cargo:
* cast:
* channel:
* coercion:
* constructor (constructor):
* consumer:
* copy:
* crates:
* dangling pointer:
* deref (dereference):
* derive:
* designator (indicator):
* destructor():
* destruction (destruction):
* diverging function (divergence function):
* drop:
* DST(Dynamically Sized Type):
* dynamic dispatch (dynamic distribution):
* enum():
* feature gate (feature switch): There is a feature switch in the nightly version to enable some experimental features
* FFI(Foreign Function Interface: Foreign Function Interface):
* guard:
* hygiene:
* inline function (inline function):
* item:
* iterator(iterator):
* iterator adapter (iterator adapter):
* lifetime (life cycle):
* lifetime elimination:
* literal string():
* macro by example:
* memberwise copy:
* module (module)
* move:
* option:
* ownership (ownership):
* panic (crash):
* phantom type:
* primitive type (basic type): integer, floating point, Boolean and other basic types
* procedural macro:
* RAII():
* raw string:
* raw pointer:
* RC (Reference Counting: Reference Counting)
* result:
* shadowing:
* static dispatch (static distribution):
* slice (slicing): a view of a certain data type, such as string, vector
* statement(): differentiated from expression
* trait:
* trait object:
* tuple (tuple):
* UFCS(Universal Function Call Syntax)
* unit():
* unwind:
* unwrap():
* wrap:
