# call the ffi function

> The ffi mentioned below all refer to cffi.

**Rust**, as a **system** level language, comes with support for ffi calls.

## Getting Start
### Import libc library

Since the data type of `cffi` is not exactly the same as `rust`, we need to introduce the `libc` library to express the type in the corresponding `ffi` function.

Add the following lines to `Cargo.toml`:

```toml
[dependencies]
libc = "0.2.9"
```

Import the library in your rs file:

```rust
extern crate libc
```

In the past, the `libc` library was released with `rust`, and later libc was moved into `crates.io` and installed through cargo.

### Declare your `ffi` function

Just like `c language` requires `#include` to declare the header file of the corresponding function, calling `ffi` in `rust` also needs to declare the corresponding function.

```rust
use libc::c_int;
use libc::c_void;
use libc::size_t;

#[link(name = "yourlib")]
extern {
    fn your_func(arg1: c_int, arg2: *mut c_void) -> size_t; // 声明ffi函数
    fn your_func2(arg1: c_int, arg2: *mut c_void) -> size_t;
    static ffi_global: c_int; // 声明ffi全局变量
}
```

Declaring a `ffi` library requires an `extern` block marked with `#[link(name = "yourlib")]`. `name` is the name of the corresponding library (`so`/`dll`/`dylib`/`a`).
For example: if you need the `snappy` library (`libsnappy.so`/`libsnappy.dll`/`libsnappy.dylib`/`libsnappy.a`), then the corresponding `name` is `snappy`.
In an `extern block` you can declare as many functions and variables as you like.

### Call the ffi function

After the declaration is complete, the call can be made.
Since this function comes from an external c library, rust cannot guarantee the safety of this function. Therefore, calling any `ffi` function requires an `unsafe` block.

```rust
let result: size_t = unsafe {
    your_func(1 as c_int, Box::into_raw(Box::new(3)) as *mut c_void)
};
```

### Encapsulate `unsafe`, expose safe interface

As a library author, exposing unsafe interfaces to the outside world is a very unqualified practice. When doing the `rust binding` of the c library, what we do most will be to encapsulate the unsafe c interface into a safe interface.
The usual way is to write all the `extern blocks` in a file called `ffi.rs` to declare the ffi function. Do the wrapping in a file called `wrapper.rs`:

```rust
// ffi.rs
#[link(name = "yourlib")]
extern {
    fn your_func(arg1: c_int, arg2: *mut c_void) -> size_t;
}
```

```rust
// wrapper.rs
fn your_func_wrapper(arg1: i32, arg2: &mut i32) -> isize {
    unsafe { your_func(1 as c_int, Box::into_raw(Box::new(3)) as *mut c_void) } as isize
}
```

Just expose (pub use) `your_func_wrapper` function to the outside world.

## Data structure correspondence

`libc` provides us with many primitive data types, such as `c_int`, `c_float`, etc., but for custom types, such as structures, we need to define them ourselves.

### Structure

The default memory representation of structures in `rust` is not compatible with c. If you want to pass the structure to the ffi function, please mark the structure of `rust`:

```rust
#[repr(C)]
struct RustObject {
    a: c_int,
    // other members
}
```

Also, using `#[repr(C, packed)]` will not pad the struct for alignment.

### Union

Unfortunately, so far (2016-03-31), rust does not have a good way to deal with the union of c. It can only be achieved with some hacks. ([corresponding to rfc](https://github.com/rust-lang/rfcs/pull/1444))

### Enum

Like `struct`, just add `#[repr(C)]` tag.

### Callback

When dealing with the C library, we often encounter a situation where a function accepts another callback function. Turning a `rust` function into a C executable callback function is very simple: add `extern "C"` in front of the function:

```rust
extern "C" fn callback(a: c_int) { // This function is passed to c to call
    println!("hello {}!", a);
}

#[link(name = "yourlib")]
extern {
   fn run_callback(data: i32, cb: extern fn(i32));
}

fn main() {
    unsafe {
        run_callback(1 as i32, callback); // print 1
    }
}
```

Corresponding to the c library code:

```c
typedef void (*rust_callback)(int32_t);

void run_callback(int32_t data, rust_callback callback) {
     callback(data); // Call the passed callback function
}
```

### string

Rust has many string types in order to deal with different situations. Among them, `CStr` and `CString` are dedicated to `ffi` interaction.

#### CStr

For strings generated in c (such as generated by using `malloc` in a c program), rust uses `CStr` to represent, corresponding to the `str` type, indicating that we do not own this string.

```rust
use std::ffi::CStr;
use libc::c_char;
#[link(name = "yourlib")]
extern {
    fn char_func() -> *mut c_char;
}

fn get_string() -> String {
    unsafe {
        let raw_string: *mut c_char = char_func();
        let cstr = CStr::from_ptr(my_string());
        cstr.to_string_lossy().into_owned()
    }
}
```

Here `get_string` uses `CStr::from_ptr` to get a string from `char*` of c and convert it into a String.

* Pay attention to the use of to_string_lossy(): because all characters in rust are represented by utf8 and c is not,
   Therefore, if you want to convert a c string to a rust string, you need to check whether they are all valid `utf-8` bytes. `to_string_lossy` will return a `Cow<str>` type,
   That is, if the c strings are all valid `utf-8` bytes, convert them to a `&str` type with 0 overhead, if not, rust will copy it and use `U+FFFD for illegal bytes `Fill.

#### CString

Contrary to `CStr` representing a string from c that rust does not own, `CString` represents a string allocated by rust to be passed to a c program.

```rust
use std::ffi::CString;
use std::os::raw::c_char;

extern {
    fn my_printer(s: *const c_char);
}

let c_to_print = CString::new("Hello, world!").unwrap();
unsafe {
    my_printer(c_to_print.as_ptr()); // Use as_ptr to convert CString into a char pointer and pass it to the c function
}
```

Note that the c string cannot contain `\0` bytes (because `\0` is used to indicate the end of the c string), so `CString::new` will return a `Result`,
`Error(NulError)` if the input has `\0`.

### Opaque structure

There is a common situation in the C library: the library author does not want the user to know the specific content of a data type, so it often provides a set of tool functions, and uses `void*` or opaque structures to pass in and out for operations.
More typical is the `WINDOW` type in the `ncurse` library.

When the parameter is `void*`, in rust, it can use the corresponding type `*mut libc::c_void` to operate like c. If the parameter is an opaque structure, a blank `enum` can be used in rust instead:

```rust
enum OpaqueStruct {}

extern "C" {
    pub fn foo(arg: *mut OpaqueStruct);
}
```

C code:

```c
struct OpaqueStruct;
void foo(struct OpaqueStruct *arg);
```

### NULL pointer

Another very common case is when a null pointer is required. Please use `0 as *const _` or `std::ptr::null()` to produce a null pointer.

## memory safety

Since `ffi` crosses the rust boundary, the rust compiler cannot guarantee the safety of the code at this time, so special attention should be paid when ffi operations are involved.

### Destruction problem

The most common problem when it comes to ffi calls is the destruction problem: who will destroy this object? Will it leak or use after free?
In some cases, the c library will pass out a type of `malloc`, and then it is no longer related to its destruction. Therefore, please implement destructors (`Drop Trait`) for these types when doing ffi operations.

### Nullable pointer optimization

When an `enum` of `rust` is a special structure: it has two instances, one is empty, and the other has only one data field, rustc will enable null pointer optimization to optimize it into a pointer.
For example `Option<extern "C" fn(c_int) -> c_int>` will be optimized into a nullable function pointer.

### ownership processing

In rust, since the compiler will automatically insert destructor code at the end of the block, extra care must be taken when using `owned` types.

```rust
extern {
    pub fn foo(arg: extern fn() -> *const c_char);
}

extern "C" fn danger() -> *const c_char {
    let cstring = CString::new("I'm a danger string").unwrap();
    cstring.as_ptr()
} // Since CString is an owned type, cstring is rust free here. USE AFTER FREE! too young!

fn main() {
  unsafe {
        foo(danger); // boom!!
    }
}
```

Since `as_ptr` accepts a `&self` as a parameter (`fn as_ptr(&self) -> *const c_char`), `ownership` is still owned by rust after `as_ptr`. So rust will destruct when the function exits.
The correct way is to use `into_raw()` instead of `as_ptr()`. Since the signature of `into_raw` is `fn into_raw(self) -> *mut c_char`, `self` is accepted, and `ownership` transfer occurs,
So `danger` function will not destroy `cstring`.

###panic

Since `panic` is an undefined behavior in `ffi`, avoid `panic` in `cffi`, including direct calls to `panic!`, `unimplemented!`, and forced `unwrap`.
When you write `cffi`, remember: every word you write could be the password to launch a **nuke**!

## Static library/Dynamic library

The way of declaring an external library was mentioned earlier - `#[link]` tag, which defaults to a dynamic library. But if it is a static library, you can use `#[link(name = "foo", kind = "static")]` to mark it.
In addition, for a special library of osx -- `framework`, you can also mark `#[link(name = "CoreFoundation", kind = "framework")]`.

## calling convention

As seen earlier, when declaring a function called by c, the syntax of `extern "C" fn` is used. Here `"C"` is the meaning of the c calling convention. In addition, rust also supports:

* stdcall
* aapcs
* cdecl
* fast call
* vectorcall //This call agreement temporarily needs to enable the abi_vectorcall feature gate.
* Rust
* rust-intrinsic
* system
* C
* win64

## bindgen

Do you think it is particularly troublesome to declare each function and global variable in the `extern block` and manually create the corresponding data structure? No problem, `rust-bindgen` is here to help you.
`rust-bindgen` is a tool that can automatically generate function declarations and data structures from corresponding c header files. Creating a binding requires only `./bindgen [options] input.h`.
[Project Address](https://github.com/crabtw/rust-bindgen)
