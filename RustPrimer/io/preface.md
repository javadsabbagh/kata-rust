# input and output

Input and output can be said to be the most basic requirements of a utility program, and a program without input and output is useless. Although input and output are despised by functional programming languages as side effects, it is this side effect that endows the program with practicality. Have you ever seen the father of a famous functional language call his leading functional language "[is useless](https: //www.youtube.com/watch?v=iSmkqocn0oQ)". In this chapter, we will talk about input and output side effects.

## Read and write traits

The most basic function of input is to read (Read), and the most basic function of output is to write (Write). In the standard library, how to read and how to write is abstracted into two interfaces `Read` and `Write`. The one that implements the `Read` interface is called a reader, and the one that implements `Write` is called a writer. Trait in Rust is better than interfaces in other languages because Trait can have a default implementation. For example, a user-defined reader only needs to implement `read` to call any other method in `Read` trait, while writer Also only need to implement `write` and `flush` two methods.

Both Trait, Read and Write, have defined many methods. For details, please refer to [Read](http://doc.rust-lang.org/stable/std/io/trait.Read.html in the standard library API documentation ) and [Write](http://doc.rust-lang.org/stable/std/io/trait.Write.html)

Read Because every call to the `read` method will call the system API to interact with the kernel, the efficiency is relatively low. If you add a buffer to the reader, when calling the `read` method, read more data and put it in the buffer. Next time you call` When using the read` method, it is possible to only fetch data from the buffer without calling the system API, thereby reducing the number of system calls and improving the reading efficiency. This is the so-called `BufRead` Trait. An ordinary reader can get a BufReader through `io::BufReader::new(reader)` or `io::BufReader::with_capacity(bufSize, reader)`, obviously one of these two functions to create BufReader is to use The default size of buffer One can specify the buffer size. The two commonly used methods of BufReader are to read by line: `read_line(&mut self, buf: &mut String) -> Result<usize>` and `lines(&mut self) -> Lines<Self>`, from the function signature You can roughly guess the usage of the function, so I wonâ€™t be verbose. It should be noted that the latter returns an iterator. See [BufRead](http://doc.rust-lang.org/stable/std/io/trait.BufRead.html) in the API documentation for details

There is also `BufWriter`, but because it does not add a new writing method except adding a buffer at the bottom layer, so there is no special `BufWrite` Trait, you can use `io::BufWriter::new(writer)` or ` io::BufWriter::with_capacity(bufSize, writer)` creates a `BufWriter`.

With the input and output interfaces, let's look at the two most commonly used types of readers and writers in practical applications: standard input/output, file input/output
