# Into/From and its application in String and &str conversion

Below `std::convert`, there are two Traits, `Into/From`, which are twin sisters. Their role is to cooperate with generics to perform some design normalization.

Their basic forms are: `From<T>` and `Into<T>`.

## From<T>

For an object `foo` of type `U`, if it implements `From<T>`, then it can be generated by `let foo = U::from(bar)`. Here, `bar` is an object of type `T`.

Here is an example, because `String` implements `From<&str>`, so `String` can be generated from `&str`.

```rust
let string = "hello".to_string();
let other_string = String::from("hello");

assert_eq!(string, other_string);
```

## Into<T>

For an object `foo` of type `U: Into<T>`, `Into` provides a function: `.into(self) -> T`, calling `foo.into()` will consume itself (transfer resource ownership), generating another new object `bar` of type `T`.

This sentence sounds a bit abstract. Let's take a specific example to help understand.

```rust
fn is_hello<T: Into<Vec<u8>>>(s: T) {
    let bytes = b"hello".to_vec();
    assert_eq!(bytes, s.into());
}

let s = "hello".to_string();
is_hello(s);
```

Because the `String` type implements `Into<Vec<u8>>`.

Let's take an example of an actual production string as a function parameter to illustrate.

When we design the `API` of the library, we often encounter an annoying problem. If the function parameter is set to `String`, when the actual parameter is passed in from the outside, for the string literal, `.to_string must be done ()` or `.to_owned()` conversion, with more parameters, is a boring and ugly thing. (If you design it in reverse, for beginners, you will encounter some life cycle problems, which is more troublesome, which will be discussed later)

So is there a way to make the parameter pass accept both the `String` type and the `&str` type? The answer is **generics**. But only generic words, too broad. Therefore, in the standard library, `Into<T>` is provided to constrain it, so as to achieve our purpose conveniently and efficiently.

For example, we have the following structure:

```rust
struct Person {
     name: String,
}

impl Person {
     fn new (name: String) -> Person {
         Person { name: name }
     }
}
```

When we call, it looks like this:

```rust
let name = "Herman".to_string();
let person = Person::new(name);
```

If written directly as:

```rust
let person = Person::new("Herman");
```

A type mismatch error will be reported.

Well, the following `Into` comes into play. We can define the structure as

```rust
struct Person {
     name: String,
}

impl Person {
     fn new<S: Into<String>>(name: S) -> Person {
         Person { name: name. into() }
     }
}
```

Then, when calling, the following two ways of writing are both possible:

```rust
fn main() {
     let person = Person::new("Herman");
     let person = Person::new("Herman".to_string());
}
```

Let's take a closer look at the writing of this piece.

```rust
impl Person {
     fn new<S: Into<String>>(name: S) -> Person {
         Person { name: name. into() }
     }
}
```

The parameter type is `S`, which is a generic parameter, which means that different types can be accepted. `S: Into<String>` indicates that `S` type must implement `Into<String>` (constraint). The `&str` type meets this requirement. So the `&str` type can be passed in directly.

And `String` itself also implements `Into<String>`. Of course, it can also be passed in directly.

Then, the following `name: name.into()` is also quite mysterious here. What it does is convert `name` into another object of type `String`. When the name is `&str`, it will be converted into a `String` object, and a copy of the string will be made (memory application, copy). And when the name itself is of type `String`, `name.into()` will not do any conversion, and the cost is zero (did you suddenly realize).

According to the reference materials, the above content can be obtained through the following three formulas:

```rust
impl<'a> From<&'a str> for String {}
impl<T> From<T> for T {}
impl<T, U> Into<U> for T where U: From<T> {}
```

For more content, please refer to:

- [http://doc.rust-lang.org/std/convert/trait.Into.html](http://doc.rust-lang.org/std/convert/trait.Into.html)
- [http://doc.rust-lang.org/std/convert/trait.From.html](http://doc.rust-lang.org/std/convert/trait.From.html)
- [http://hermanradtke.com/2015/05/06/creating-a-rust-function-that-accepts-string-or-str.html](http://hermanradtke.com/2015/05/06 /creating-a-rust-function-that-accepts-string-or-str.html)
